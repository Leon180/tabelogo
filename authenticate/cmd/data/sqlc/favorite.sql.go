// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: favorite.sql

package db

import (
	"context"
	"time"

	"github.com/lib/pq"
)

const createFavorite = `-- name: CreateFavorite :one
INSERT INTO favorites (
    user_email,
    google_id
) VALUES (
    $1, 
    $2
) RETURNING is_favorite, user_email, google_id, created_at, updated_at
`

type CreateFavoriteParams struct {
	UserEmail string `json:"user_email"`
	GoogleID  string `json:"google_id"`
}

func (q *Queries) CreateFavorite(ctx context.Context, arg CreateFavoriteParams) (Favorite, error) {
	row := q.db.QueryRowContext(ctx, createFavorite, arg.UserEmail, arg.GoogleID)
	var i Favorite
	err := row.Scan(
		&i.IsFavorite,
		&i.UserEmail,
		&i.GoogleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCountryList = `-- name: GetCountryList :many
SELECT DISTINCT country FROM favorites JOIN places ON favorites.google_id = places.google_id
WHERE favorites.user_email = $1 AND favorites.is_favorite = true
ORDER BY country ASC
`

func (q *Queries) GetCountryList(ctx context.Context, userEmail string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCountryList, userEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var country string
		if err := rows.Scan(&country); err != nil {
			return nil, err
		}
		items = append(items, country)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFavorite = `-- name: GetFavorite :one
SELECT is_favorite, user_email, google_id, created_at, updated_at FROM favorites
WHERE user_email = $1 AND google_id = $2 AND is_favorite = true
`

type GetFavoriteParams struct {
	UserEmail string `json:"user_email"`
	GoogleID  string `json:"google_id"`
}

func (q *Queries) GetFavorite(ctx context.Context, arg GetFavoriteParams) (Favorite, error) {
	row := q.db.QueryRowContext(ctx, getFavorite, arg.UserEmail, arg.GoogleID)
	var i Favorite
	err := row.Scan(
		&i.IsFavorite,
		&i.UserEmail,
		&i.GoogleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRegionList = `-- name: GetRegionList :many
SELECT DISTINCT administrative_area_level_1 FROM favorites JOIN places ON favorites.google_id = places.google_id
WHERE favorites.user_email = $1 AND places.country = $2 AND favorites.is_favorite = true
ORDER BY administrative_area_level_1 ASC
`

type GetRegionListParams struct {
	UserEmail string `json:"user_email"`
	Country   string `json:"country"`
}

func (q *Queries) GetRegionList(ctx context.Context, arg GetRegionListParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getRegionList, arg.UserEmail, arg.Country)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var administrative_area_level_1 string
		if err := rows.Scan(&administrative_area_level_1); err != nil {
			return nil, err
		}
		items = append(items, administrative_area_level_1)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFavoritesByCountrAndRegion = `-- name: ListFavoritesByCountrAndRegion :many
SELECT
    favorites.google_id,
    tw_display_name,
    tw_formatted_address,
    tw_weekday_descriptions,
    administrative_area_level_1,
    country,
    google_map_uri,
    international_phone_number,
    lat,
    lng,
    primary_type,
    rating,
    types,
    user_rating_count,
    website_uri
FROM favorites JOIN places ON favorites.google_id = places.google_id
WHERE favorites.user_email = $1 AND places.country = $2 AND places.administrative_area_level_1 = $3 AND favorites.is_favorite = true
ORDER BY favorites.created_at ASC
LIMIT $4
OFFSET $5
`

type ListFavoritesByCountrAndRegionParams struct {
	UserEmail                string `json:"user_email"`
	Country                  string `json:"country"`
	AdministrativeAreaLevel1 string `json:"administrative_area_level_1"`
	Limit                    int32  `json:"limit"`
	Offset                   int32  `json:"offset"`
}

type ListFavoritesByCountrAndRegionRow struct {
	GoogleID                 string   `json:"google_id"`
	TwDisplayName            string   `json:"tw_display_name"`
	TwFormattedAddress       string   `json:"tw_formatted_address"`
	TwWeekdayDescriptions    []string `json:"tw_weekday_descriptions"`
	AdministrativeAreaLevel1 string   `json:"administrative_area_level_1"`
	Country                  string   `json:"country"`
	GoogleMapUri             string   `json:"google_map_uri"`
	InternationalPhoneNumber string   `json:"international_phone_number"`
	Lat                      string   `json:"lat"`
	Lng                      string   `json:"lng"`
	PrimaryType              string   `json:"primary_type"`
	Rating                   string   `json:"rating"`
	Types                    []string `json:"types"`
	UserRatingCount          int32    `json:"user_rating_count"`
	WebsiteUri               string   `json:"website_uri"`
}

func (q *Queries) ListFavoritesByCountrAndRegion(ctx context.Context, arg ListFavoritesByCountrAndRegionParams) ([]ListFavoritesByCountrAndRegionRow, error) {
	rows, err := q.db.QueryContext(ctx, listFavoritesByCountrAndRegion,
		arg.UserEmail,
		arg.Country,
		arg.AdministrativeAreaLevel1,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFavoritesByCountrAndRegionRow
	for rows.Next() {
		var i ListFavoritesByCountrAndRegionRow
		if err := rows.Scan(
			&i.GoogleID,
			&i.TwDisplayName,
			&i.TwFormattedAddress,
			pq.Array(&i.TwWeekdayDescriptions),
			&i.AdministrativeAreaLevel1,
			&i.Country,
			&i.GoogleMapUri,
			&i.InternationalPhoneNumber,
			&i.Lat,
			&i.Lng,
			&i.PrimaryType,
			&i.Rating,
			pq.Array(&i.Types),
			&i.UserRatingCount,
			&i.WebsiteUri,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFavoritesByCountry = `-- name: ListFavoritesByCountry :many
SELECT
    favorites.google_id,
    tw_display_name,
    tw_formatted_address,
    tw_weekday_descriptions,
    administrative_area_level_1,
    country,
    google_map_uri,
    international_phone_number,
    lat,
    lng,
    primary_type,
    rating,
    types,
    user_rating_count,
    website_uri
FROM favorites JOIN places ON favorites.google_id = places.google_id
WHERE favorites.user_email = $1 AND places.country = $2 AND favorites.is_favorite = true
ORDER BY favorites.created_at ASC
LIMIT $3
OFFSET $4
`

type ListFavoritesByCountryParams struct {
	UserEmail string `json:"user_email"`
	Country   string `json:"country"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

type ListFavoritesByCountryRow struct {
	GoogleID                 string   `json:"google_id"`
	TwDisplayName            string   `json:"tw_display_name"`
	TwFormattedAddress       string   `json:"tw_formatted_address"`
	TwWeekdayDescriptions    []string `json:"tw_weekday_descriptions"`
	AdministrativeAreaLevel1 string   `json:"administrative_area_level_1"`
	Country                  string   `json:"country"`
	GoogleMapUri             string   `json:"google_map_uri"`
	InternationalPhoneNumber string   `json:"international_phone_number"`
	Lat                      string   `json:"lat"`
	Lng                      string   `json:"lng"`
	PrimaryType              string   `json:"primary_type"`
	Rating                   string   `json:"rating"`
	Types                    []string `json:"types"`
	UserRatingCount          int32    `json:"user_rating_count"`
	WebsiteUri               string   `json:"website_uri"`
}

func (q *Queries) ListFavoritesByCountry(ctx context.Context, arg ListFavoritesByCountryParams) ([]ListFavoritesByCountryRow, error) {
	rows, err := q.db.QueryContext(ctx, listFavoritesByCountry,
		arg.UserEmail,
		arg.Country,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFavoritesByCountryRow
	for rows.Next() {
		var i ListFavoritesByCountryRow
		if err := rows.Scan(
			&i.GoogleID,
			&i.TwDisplayName,
			&i.TwFormattedAddress,
			pq.Array(&i.TwWeekdayDescriptions),
			&i.AdministrativeAreaLevel1,
			&i.Country,
			&i.GoogleMapUri,
			&i.InternationalPhoneNumber,
			&i.Lat,
			&i.Lng,
			&i.PrimaryType,
			&i.Rating,
			pq.Array(&i.Types),
			&i.UserRatingCount,
			&i.WebsiteUri,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFavoritesByCreateTime = `-- name: ListFavoritesByCreateTime :many
SELECT
    favorites.google_id,
    tw_display_name,
    tw_formatted_address,
    tw_weekday_descriptions,
    administrative_area_level_1,
    country,
    google_map_uri,
    international_phone_number,
    lat,
    lng,
    primary_type,
    rating,
    types,
    user_rating_count,
    website_uri,
    favorites.created_at,
    favorites.updated_at
FROM favorites JOIN places ON favorites.google_id = places.google_id
WHERE favorites.user_email = $1 AND favorites.is_favorite = true
ORDER BY favorites.created_at ASC
LIMIT $2
OFFSET $3
`

type ListFavoritesByCreateTimeParams struct {
	UserEmail string `json:"user_email"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

type ListFavoritesByCreateTimeRow struct {
	GoogleID                 string    `json:"google_id"`
	TwDisplayName            string    `json:"tw_display_name"`
	TwFormattedAddress       string    `json:"tw_formatted_address"`
	TwWeekdayDescriptions    []string  `json:"tw_weekday_descriptions"`
	AdministrativeAreaLevel1 string    `json:"administrative_area_level_1"`
	Country                  string    `json:"country"`
	GoogleMapUri             string    `json:"google_map_uri"`
	InternationalPhoneNumber string    `json:"international_phone_number"`
	Lat                      string    `json:"lat"`
	Lng                      string    `json:"lng"`
	PrimaryType              string    `json:"primary_type"`
	Rating                   string    `json:"rating"`
	Types                    []string  `json:"types"`
	UserRatingCount          int32     `json:"user_rating_count"`
	WebsiteUri               string    `json:"website_uri"`
	CreatedAt                time.Time `json:"created_at"`
	UpdatedAt                time.Time `json:"updated_at"`
}

func (q *Queries) ListFavoritesByCreateTime(ctx context.Context, arg ListFavoritesByCreateTimeParams) ([]ListFavoritesByCreateTimeRow, error) {
	rows, err := q.db.QueryContext(ctx, listFavoritesByCreateTime, arg.UserEmail, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFavoritesByCreateTimeRow
	for rows.Next() {
		var i ListFavoritesByCreateTimeRow
		if err := rows.Scan(
			&i.GoogleID,
			&i.TwDisplayName,
			&i.TwFormattedAddress,
			pq.Array(&i.TwWeekdayDescriptions),
			&i.AdministrativeAreaLevel1,
			&i.Country,
			&i.GoogleMapUri,
			&i.InternationalPhoneNumber,
			&i.Lat,
			&i.Lng,
			&i.PrimaryType,
			&i.Rating,
			pq.Array(&i.Types),
			&i.UserRatingCount,
			&i.WebsiteUri,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFavorite = `-- name: RemoveFavorite :exec
DELETE FROM favorites
WHERE user_email = $1 AND google_id = $2 AND is_favorite = true
`

type RemoveFavoriteParams struct {
	UserEmail string `json:"user_email"`
	GoogleID  string `json:"google_id"`
}

func (q *Queries) RemoveFavorite(ctx context.Context, arg RemoveFavoriteParams) error {
	_, err := q.db.ExecContext(ctx, removeFavorite, arg.UserEmail, arg.GoogleID)
	return err
}

const toggleFavorite = `-- name: ToggleFavorite :one
INSERT INTO favorites (
    user_email,
    google_id
) VALUES (
    $1, 
    $2
) ON CONFLICT (user_email, google_id) DO 
UPDATE SET is_favorite = NOT favorites.is_favorite, updated_at = NOW()
RETURNING is_favorite, user_email, google_id, created_at, updated_at
`

type ToggleFavoriteParams struct {
	UserEmail string `json:"user_email"`
	GoogleID  string `json:"google_id"`
}

func (q *Queries) ToggleFavorite(ctx context.Context, arg ToggleFavoriteParams) (Favorite, error) {
	row := q.db.QueryRowContext(ctx, toggleFavorite, arg.UserEmail, arg.GoogleID)
	var i Favorite
	err := row.Scan(
		&i.IsFavorite,
		&i.UserEmail,
		&i.GoogleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
