// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: favorite.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const createFavorite = `-- name: CreateFavorite :one
INSERT INTO favorites (
    user_id,
    google_id
) VALUES (
    $1, 
    $2
) RETURNING favorite_id, user_id, google_id, created_at, updated_at
`

type CreateFavoriteParams struct {
	UserID   int64  `json:"user_id"`
	GoogleID string `json:"google_id"`
}

func (q *Queries) CreateFavorite(ctx context.Context, arg CreateFavoriteParams) (Favorite, error) {
	row := q.db.QueryRowContext(ctx, createFavorite, arg.UserID, arg.GoogleID)
	var i Favorite
	err := row.Scan(
		&i.FavoriteID,
		&i.UserID,
		&i.GoogleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCountryList = `-- name: GetCountryList :many
SELECT DISTINCT country FROM favorites JOIN places ON favorites.google_id = places.google_id
WHERE user_id = $1
ORDER BY country ASC
`

func (q *Queries) GetCountryList(ctx context.Context, userID int64) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, getCountryList, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var country sql.NullString
		if err := rows.Scan(&country); err != nil {
			return nil, err
		}
		items = append(items, country)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFavorite = `-- name: GetFavorite :one
SELECT favorite_id, user_id, google_id, created_at, updated_at FROM favorites
WHERE user_id = $1 AND google_id = $2
`

type GetFavoriteParams struct {
	UserID   int64  `json:"user_id"`
	GoogleID string `json:"google_id"`
}

func (q *Queries) GetFavorite(ctx context.Context, arg GetFavoriteParams) (Favorite, error) {
	row := q.db.QueryRowContext(ctx, getFavorite, arg.UserID, arg.GoogleID)
	var i Favorite
	err := row.Scan(
		&i.FavoriteID,
		&i.UserID,
		&i.GoogleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRegionList = `-- name: GetRegionList :many
SELECT DISTINCT administrative_area_level_1 FROM favorites JOIN places ON favorites.google_id = places.google_id
WHERE user_id = $1 AND country = $2
ORDER BY administrative_area_level_1 ASC
`

type GetRegionListParams struct {
	UserID  int64          `json:"user_id"`
	Country sql.NullString `json:"country"`
}

func (q *Queries) GetRegionList(ctx context.Context, arg GetRegionListParams) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, getRegionList, arg.UserID, arg.Country)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var administrative_area_level_1 sql.NullString
		if err := rows.Scan(&administrative_area_level_1); err != nil {
			return nil, err
		}
		items = append(items, administrative_area_level_1)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFavoritesByCountrAndRegion = `-- name: ListFavoritesByCountrAndRegion :many
SELECT
    favorites.google_id,
    tw_display_name,
    tw_formatted_address,
    tw_weekday_descriptions,
    administrative_area_level_1,
    country,
    google_map_uri,
    international_phone_number,
    lat,
    lng,
    primary_type,
    rating,
    types,
    user_rating_count,
    website_uri,
    favorites.created_at,
    favorites.updated_at,
    favorite_id
FROM favorites JOIN places ON favorites.google_id = places.google_id
WHERE user_id = $1 AND country = $2 AND administrative_area_level_1 = $3
ORDER BY favorites.created_at ASC
LIMIT $4
OFFSET $5
`

type ListFavoritesByCountrAndRegionParams struct {
	UserID                   int64          `json:"user_id"`
	Country                  sql.NullString `json:"country"`
	AdministrativeAreaLevel1 sql.NullString `json:"administrative_area_level_1"`
	Limit                    int32          `json:"limit"`
	Offset                   int32          `json:"offset"`
}

type ListFavoritesByCountrAndRegionRow struct {
	GoogleID                 string         `json:"google_id"`
	TwDisplayName            string         `json:"tw_display_name"`
	TwFormattedAddress       string         `json:"tw_formatted_address"`
	TwWeekdayDescriptions    []string       `json:"tw_weekday_descriptions"`
	AdministrativeAreaLevel1 sql.NullString `json:"administrative_area_level_1"`
	Country                  sql.NullString `json:"country"`
	GoogleMapUri             string         `json:"google_map_uri"`
	InternationalPhoneNumber sql.NullString `json:"international_phone_number"`
	Lat                      string         `json:"lat"`
	Lng                      string         `json:"lng"`
	PrimaryType              sql.NullString `json:"primary_type"`
	Rating                   sql.NullString `json:"rating"`
	Types                    []string       `json:"types"`
	UserRatingCount          sql.NullInt32  `json:"user_rating_count"`
	WebsiteUri               sql.NullString `json:"website_uri"`
	CreatedAt                time.Time      `json:"created_at"`
	UpdatedAt                time.Time      `json:"updated_at"`
	FavoriteID               int64          `json:"favorite_id"`
}

func (q *Queries) ListFavoritesByCountrAndRegion(ctx context.Context, arg ListFavoritesByCountrAndRegionParams) ([]ListFavoritesByCountrAndRegionRow, error) {
	rows, err := q.db.QueryContext(ctx, listFavoritesByCountrAndRegion,
		arg.UserID,
		arg.Country,
		arg.AdministrativeAreaLevel1,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFavoritesByCountrAndRegionRow
	for rows.Next() {
		var i ListFavoritesByCountrAndRegionRow
		if err := rows.Scan(
			&i.GoogleID,
			&i.TwDisplayName,
			&i.TwFormattedAddress,
			pq.Array(&i.TwWeekdayDescriptions),
			&i.AdministrativeAreaLevel1,
			&i.Country,
			&i.GoogleMapUri,
			&i.InternationalPhoneNumber,
			&i.Lat,
			&i.Lng,
			&i.PrimaryType,
			&i.Rating,
			pq.Array(&i.Types),
			&i.UserRatingCount,
			&i.WebsiteUri,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FavoriteID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFavoritesByCountry = `-- name: ListFavoritesByCountry :many
SELECT
    favorites.google_id,
    tw_display_name,
    tw_formatted_address,
    tw_weekday_descriptions,
    administrative_area_level_1,
    country,
    google_map_uri,
    international_phone_number,
    lat,
    lng,
    primary_type,
    rating,
    types,
    user_rating_count,
    website_uri,
    favorites.created_at,
    favorites.updated_at,
    favorite_id
FROM favorites JOIN places ON favorites.google_id = places.google_id
WHERE user_id = $1 AND country = $2
ORDER BY favorites.created_at ASC
LIMIT $3
OFFSET $4
`

type ListFavoritesByCountryParams struct {
	UserID  int64          `json:"user_id"`
	Country sql.NullString `json:"country"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

type ListFavoritesByCountryRow struct {
	GoogleID                 string         `json:"google_id"`
	TwDisplayName            string         `json:"tw_display_name"`
	TwFormattedAddress       string         `json:"tw_formatted_address"`
	TwWeekdayDescriptions    []string       `json:"tw_weekday_descriptions"`
	AdministrativeAreaLevel1 sql.NullString `json:"administrative_area_level_1"`
	Country                  sql.NullString `json:"country"`
	GoogleMapUri             string         `json:"google_map_uri"`
	InternationalPhoneNumber sql.NullString `json:"international_phone_number"`
	Lat                      string         `json:"lat"`
	Lng                      string         `json:"lng"`
	PrimaryType              sql.NullString `json:"primary_type"`
	Rating                   sql.NullString `json:"rating"`
	Types                    []string       `json:"types"`
	UserRatingCount          sql.NullInt32  `json:"user_rating_count"`
	WebsiteUri               sql.NullString `json:"website_uri"`
	CreatedAt                time.Time      `json:"created_at"`
	UpdatedAt                time.Time      `json:"updated_at"`
	FavoriteID               int64          `json:"favorite_id"`
}

func (q *Queries) ListFavoritesByCountry(ctx context.Context, arg ListFavoritesByCountryParams) ([]ListFavoritesByCountryRow, error) {
	rows, err := q.db.QueryContext(ctx, listFavoritesByCountry,
		arg.UserID,
		arg.Country,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFavoritesByCountryRow
	for rows.Next() {
		var i ListFavoritesByCountryRow
		if err := rows.Scan(
			&i.GoogleID,
			&i.TwDisplayName,
			&i.TwFormattedAddress,
			pq.Array(&i.TwWeekdayDescriptions),
			&i.AdministrativeAreaLevel1,
			&i.Country,
			&i.GoogleMapUri,
			&i.InternationalPhoneNumber,
			&i.Lat,
			&i.Lng,
			&i.PrimaryType,
			&i.Rating,
			pq.Array(&i.Types),
			&i.UserRatingCount,
			&i.WebsiteUri,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FavoriteID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFavoritesByCreateTime = `-- name: ListFavoritesByCreateTime :many
SELECT
    favorites.google_id,
    tw_display_name,
    tw_formatted_address,
    tw_weekday_descriptions,
    administrative_area_level_1,
    country,
    google_map_uri,
    international_phone_number,
    lat,
    lng,
    primary_type,
    rating,
    types,
    user_rating_count,
    website_uri,
    favorites.created_at,
    favorites.updated_at,
    favorite_id
FROM favorites JOIN places ON favorites.google_id = places.google_id
WHERE user_id = $1
ORDER BY favorites.created_at ASC
LIMIT $2
OFFSET $3
`

type ListFavoritesByCreateTimeParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListFavoritesByCreateTimeRow struct {
	GoogleID                 string         `json:"google_id"`
	TwDisplayName            string         `json:"tw_display_name"`
	TwFormattedAddress       string         `json:"tw_formatted_address"`
	TwWeekdayDescriptions    []string       `json:"tw_weekday_descriptions"`
	AdministrativeAreaLevel1 sql.NullString `json:"administrative_area_level_1"`
	Country                  sql.NullString `json:"country"`
	GoogleMapUri             string         `json:"google_map_uri"`
	InternationalPhoneNumber sql.NullString `json:"international_phone_number"`
	Lat                      string         `json:"lat"`
	Lng                      string         `json:"lng"`
	PrimaryType              sql.NullString `json:"primary_type"`
	Rating                   sql.NullString `json:"rating"`
	Types                    []string       `json:"types"`
	UserRatingCount          sql.NullInt32  `json:"user_rating_count"`
	WebsiteUri               sql.NullString `json:"website_uri"`
	CreatedAt                time.Time      `json:"created_at"`
	UpdatedAt                time.Time      `json:"updated_at"`
	FavoriteID               int64          `json:"favorite_id"`
}

func (q *Queries) ListFavoritesByCreateTime(ctx context.Context, arg ListFavoritesByCreateTimeParams) ([]ListFavoritesByCreateTimeRow, error) {
	rows, err := q.db.QueryContext(ctx, listFavoritesByCreateTime, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFavoritesByCreateTimeRow
	for rows.Next() {
		var i ListFavoritesByCreateTimeRow
		if err := rows.Scan(
			&i.GoogleID,
			&i.TwDisplayName,
			&i.TwFormattedAddress,
			pq.Array(&i.TwWeekdayDescriptions),
			&i.AdministrativeAreaLevel1,
			&i.Country,
			&i.GoogleMapUri,
			&i.InternationalPhoneNumber,
			&i.Lat,
			&i.Lng,
			&i.PrimaryType,
			&i.Rating,
			pq.Array(&i.Types),
			&i.UserRatingCount,
			&i.WebsiteUri,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FavoriteID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFavorite = `-- name: RemoveFavorite :exec
DELETE FROM favorites
WHERE user_id = $1 AND google_id = $2
`

type RemoveFavoriteParams struct {
	UserID   int64  `json:"user_id"`
	GoogleID string `json:"google_id"`
}

func (q *Queries) RemoveFavorite(ctx context.Context, arg RemoveFavoriteParams) error {
	_, err := q.db.ExecContext(ctx, removeFavorite, arg.UserID, arg.GoogleID)
	return err
}
